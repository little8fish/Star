---
title: essential_c++
abbrlink: 21be6370
date: 2023-03-02 10:27:03
tags: [essential c++]
categories: 阅读记录
cover: https://images.unsplash.com/photo-1677613935629-5de03180c113?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=735&q=80
---
{% note info simple %}
1. 局部对象以传值方式返回，便不会产生任何问题，因为返回的是对象的副本；局部对象以pointer或reference返回，都不正确。
2. 对象如果在函数以外声明，具有所谓的file scope；file scope内的对象具备所谓的static extent，即该对象的内存在main()开始执行之前便已经分配好了，可以一直存在至程序结束。
3. 内置类型的对象，如果定义在file scope之内，必定被初始化为0；但如果他们被定义于local scope之内，那么要手动初始化。
4. 不论是local scope或file scope，对我们而言，都是由系统自动管理；第三种存储期形式称为dynamic extent（动态范围）；其内存系程序的空闲空间分配而来，有时也称为heap memory（堆内存）。
5. 函数参数默认值只能够指定一次，可以在函数声明处，也可以在函数定义处，但不能够在两个地方都指定；为了更高的可见性，我们决定将默认值放在函数声明处。
6. 局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在；局部静态对象与全局变量共享全局数据区，但局部静态对象只在定义它的函数中可见
7. 将函数声明为inline，只是对编译器提出的一种要求；编译器是否执行这项请求，需视编译器而定
8. 编译器无法根据函数返回类型来区分两个具有相同名称的函数
9. function template同时也可以是重载函数
10. 函数指针调用方式：函数指针名（参数）；还有函数指针数组`int (*fun_ptr[])(void)`
11. 函数的定义只能有一份，不过可以有许多份声明；我们不把函数的定义放入头文件，因为同一个程序的多个代码文件可能都会包含这个头文件
12. “只定义一份”有个例外，inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中
13. 如果文件被认定为标准的或项目专属的头文件，便以尖括号将文件名括住；编译器搜索此文件时，会现在某些默认的磁盘目录中寻找。若果文件名由成对的双引号括住，比文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件所在的磁盘目录中开始找起
14. const object的定义只要一出文件之外便不可见
{% endnote %}
