---
title: c++
abbrlink: 21be6370
date: 2023-03-02 10:27:03
top: 1
tags: [essential c++,c++ primer]
categories: 阅读记录
cover: https://images.unsplash.com/photo-1677613935629-5de03180c113?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=735&q=80
---
### essential c++
1. 局部对象以传值方式返回，便不会产生任何问题，因为返回的是对象的副本；局部对象以pointer或reference返回，都不正确。
2. 对象如果在函数以外声明，具有所谓的file scope；file scope内的对象具备所谓的static extent，即该对象的内存在main()开始执行之前便已经分配好了，可以一直存在至程序结束。
3. 内置类型的对象，如果定义在file scope之内，必定被初始化为0；但如果他们被定义于local scope之内，那么要手动初始化。
4. 不论是local scope或file scope，对我们而言，都是由系统自动管理；第三种存储期形式称为dynamic extent（动态范围）；其内存系程序的空闲空间分配而来，有时也称为heap memory（堆内存）。
5. 函数参数默认值只能够指定一次，可以在函数声明处，也可以在函数定义处，但不能够在两个地方都指定；为了更高的可见性，我们决定将默认值放在函数声明处。
6. 局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在；局部静态对象与全局变量共享全局数据区，但局部静态对象只在定义它的函数中可见
7. 将函数声明为inline，只是对编译器提出的一种要求；编译器是否执行这项请求，需视编译器而定
8. 编译器无法根据函数返回类型来区分两个具有相同名称的函数
9. function template同时也可以是重载函数
10. 函数指针调用方式：函数指针名（参数）；还有函数指针数组`int (*fun_ptr[])(void)`
11. 函数的定义只能有一份，不过可以有许多份声明；我们不把函数的定义放入头文件，因为同一个程序的多个代码文件可能都会包含这个头文件
12. “只定义一份”有个例外，inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中
13. 如果文件被认定为标准的或项目专属的头文件，便以尖括号将文件名括住；编译器搜索此文件时，会现在某些默认的磁盘目录中寻找。若果文件名由成对的双引号括住，比文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件所在的磁盘目录中开始找起
14. const object的定义只要一出文件之外便不可见

### effective c++
1. 四个语言层次
2. const替换#define 常量声明式 
3. 

### modern c++

1. auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。
2. 现代 C++ 还为自身的标准库增加了非常多的工具和方法，诸如在语言自身标准的层面上制定了 std::thread，从而支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex 提供了完整的正则表达式支持等等。
3. 本书将使用 clang++ 作为唯一使用的编译器，同时总是在代码中使用 -std=c++2a 编译标志
4. 弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。
5. ![弃用特性](https://i.328888.xyz/2023/03/06/deBrz.jpeg)
6. 在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern "C" 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法
7. Makefile 中的缩进是制表符而不是空格符，如果你直接复制这段代码到你的编辑器中，制表符可能会被自动替换掉，请自行确保在 Makefile 中的缩进是由制表符完成的。
8.  C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较.
9.  C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。
10. C++ 标准中数组的长度必须是一个常量表达式;
11. 现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。
12. C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 len_foo 在编译期就应该是一个常量表达式。
13. C++17 消除了这一限制，使得我们可以在 if（或 switch）中声明一个临时的变量
14. C++11 首先把初始化列表的概念绑定到类型上，称其为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁。这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。
15. 初始化列表除了用在对象构造上，还能将其作为普通函数的形参.
16. 提供一种简单的方法直接从元组中拿到并定义元组中的元素 结构化绑定 `auto [x, y, z] = f();`
17. decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。`decltype(x+y) z;`z的类型为`decltype(x+y)`
18. 从 C++ 20 起，auto 甚至能用于函数传参;auto 还不能用于推导数组类型
19. typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义
20. C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置
21. 令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导
22. decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。
23. C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件;if constexpr 让代码在编译时就完成分支判断
24. 区间for迭代
25. 模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。
26. C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化
27. 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。
28. C++11 使用 using 引入了为模板定义一个新的名称，并且同时支持对传统 typedef 相同的功效
29. 而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。```template<typename Require, typename... Args> class Magic;```
30. 传统 C 中的 printf 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。
31. 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 printf 的函数能自然地处理非自带类别的对象。
32.  除了在模板参数中能使用 ... 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段
33.  我们可以使用 sizeof... 来计算参数的个数
34. 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法: 递归模板函数 变参模板展开
35. 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。
36. 初始化列表展开  通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。 为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void。
37. C++ 17 中将变长参数这种特性进一步带给了表达式 ```auto sum(T ... t) {
    return (t + ...);
}```
38. 还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数
39. 既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 auto 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导
40. C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的
41. 在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念
42. 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译
43. final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。
44. 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。 当程序员有需要时，可以重载这部分函数。
45. 编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬
46. 允许显式的声明采用或拒绝编译器自带的函数。
47. 在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果
48. C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明  这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较
49. 在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。
50. 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 << 这个算符来进行输出，可以收藏下面这个代码段： 这段代码不懂
51. 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。
52. 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝
53. 与引用传参类似，引用捕获保存的是引用，值会发生变化
54. 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用引用捕获或者值捕获.
55. C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的
56. 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型
57. Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递
58. 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。
59. C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。
60.  std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用
61.  注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 auto 的使用来规避这一问题的出现。
62.  左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。
63.  左值能取地址 右值不能取地址
64.  需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。
65.  const char*&& pr  = "01234";  // 正确，"01234" 被隐式转换为 const char*，该转换的结果是纯右值
66.  将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。
67.  此处的左值 temp 会被进行此隐式右值转换， 等价于 static_cast<std::vector<int> &&>(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。 
68.  要拿到一个将亡值，就需要用到右值引用：T &&，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。
69.  C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象
70.  rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。
71.  对右值引用后 有了名字 这个名字就成了左值
72.  左值引用只能绑定左值 右值引用只能绑定右值
73.  常量左值引用可以绑定非常量左值、常量左值、右值 而且绑定右值的时候 常量左值引用还可以像右值引用一样将右值的生命期延长
74.  右值引用将右值的生命期延长
75.  这里介绍了左值 右值 移动语义 完美转发 https://www.bilibili.com/video/BV1D84y1z7kT/?p=3&spm_id_from=pageDriver&vd_source=8f841660eaffa503121a503667bfc063
76.      // 将使用 push_back(const T&&), 不会出现拷贝行为
    // 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销
    // 这步操作后, str 中的值会变为空 为什么会变空 移动吗
    v.push_back(std::move(str));
77.  一个声明的右值引用其实是一个左值
78.  无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发， 所以 std::move 总会接受到一个左值，从而转发调用了reference(int&&) 输出右值引用。
79.  std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看， std::forward<T>(v) 和 static_cast<T&&>(v) 是完全一样的。
80.  当 std::forward 接受左值时，_Tp 被推导为左值，所以返回值为左值；而当其接受右值时， _Tp 被推导为 右值引用，则基于坍缩规则，返回值便成为了 && + && 的右值。 可见 std::forward 的原理在于巧妙的利用了模板类型推导中产生的差异。  这一句不懂
81.  为什么在使用循环语句的过程中，auto&& 是最安全的方式？ 因为当 auto 被推导为不同的左右引用时，与 && 的坍缩组合是完美转发。
82.  先回答第一个问题，与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 std::array 容器。 另外由于 std::vector 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 shrink_to_fit() 释放这部分内存。
83.  当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法
84.  需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。
85.  我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 < 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 < 操作符的顺序来逐个遍历。
86.  而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)， 在不关心容器内部元素顺序时，能够获得显著的性能提升。
87.  关于元组的使用有三个核心的函数：
    std::make_tuple: 构造元组
    std::get: 获得元组某个位置的值
    std::tie: 元组拆包
88.  std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象
89.  std::get<> 依赖一个编译期的常量，所以下面的方式是不合法的
90.  还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现
91.  std::tuple 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他的方法可以自行实现。
92.  引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。
93.  所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。
94.  而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 <memory>。
95.  引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。
96.  std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。std::make_shared 就能够用来消除显式的使用 new，所以std::make_shared 会分配创建传入参数中的对象， 并返回这个对象类型的std::shared_ptr指针。
97.  std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。
98.  所有的共享指针被摧毁 而裸指针依然存在时 内存依旧会被释放 而此时访问裸指针就变成了未被定义的行为 记住 智能指针和裸指针不要混用
99.  std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全
100. reset可以指向一个新的内存 sp.reset(new Ball)
101. 可以自定义一个删除函数 告诉share_ptr如何释放资源
102. shared_ptr别名 `shared_ptr<Bar> b(f, &(f->bar))` b拥有对f指向物体的管理权 f引用计数增加1 b的数据指针指向的是bar 通常这个技巧用于访问类的成员变量 我们访问的是某个实例的成员 但是我们不希望在用这个成员的时候 实例本身被删除 所以我们增加了对这个实例的控制权 额外性能开销
103. 在使用智能指针的时候 尽量避免使用手动的delete
104. 但是，我们可以利用 std::move 将其转移给其他的 unique_ptr 0开销
105. unique_ptr可以用release返回裸指针 并把unique_ptr设置为nullptr 把unique_ptr赋值为nullptr也会释放资源  return返回 自动帮我们使用移动构造 传递时设置u_p的引用 
106. 默认情况下 u_p使用new delete获取释放资源 也可以自定义 u_p绑定释放函数是在编译器  s_p是在运行期
107. std::shared_ptr 就会发现依然存在着资源无法释放的问题。
108. 弱引用不会引起引用计数增加
109. std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true；除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回nullptr。
110. 智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在一定程度上消除了 new/delete 的滥用，是一种更加成熟的编程范式。
111. 智能指针快速讲解视频 ——> [hexup的视频](https://www.bilibili.com/video/BV1Ye4y127rZ/?spm_id_from=333.999.0.0&vd_source=8f841660eaffa503121a503667bfc063)
112. 正则表达式
113. 并行与并发
114. 文件系统
115. 其它
116. 展望
117. 

### c++ primer 按需查找
1. echo $? 上一个命令的返回值 $$
2. 11新标准允许派生类显示地注明它使用某个成员函数覆盖它继承的虚函数 override
3. 常量表达式(constexpression)是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。
4. C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化
5. 新标准允许定义-种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。
6. 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。允许函数定义一-类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr 引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。
7. 必须明确一点， 在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关;与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量
8. constexpr函数(constexpr function)是指能用于常量表达式的函数。定义constexpr 函数的方法与其他函数相似，不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句
9. 为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr 函数中可以有空语句、类型别名以及using声明。
10. 我们允许constexpr函数的返回值并非-一个常量.constexpr函数不一定返回常量表达式。
11. 和其他函数不一一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全-致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。
12. assert是一种 预处理宏( preprocessor marco)。所谓预处理宏其实是-一个预处理变量,它的行为有点类似于内联函数。
13. 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。
14. constexpr构造函数就必须既符合构造函数的要求(意味着不能包含返回语句)，又符合constexpr函数的要求(意味着它能拥有的唯一可执行语句就是返回语句。综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了
15. constexpr构造函数必须初始化所有数据成员,初始值或者使用constexpr构造函数，或者是一条常量表达式.constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型.
16. 有时(但并不频繁)会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员(mutable data member)永远不会是const,即使它是const对象的成员。因此，-个const成员函数可以改变-个可变成员的值.
17. 直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile。关键字volatile告诉编译器不应对这样的对象进行优化。volatile限定符的用法和const很相似，它起到对类型额外修饰的作用。
18. 就像一个类可以定义const成员函数一样，它也可以将成员函数定义成volatile的。只有volatile的成员函数才能被volatile的对象调用。2.4.2节(第56页)描述了const限定符和指针的相互作用，在volatile限定符和指针之间也存在类似的关系。我们可以声明volatile指针、指向volatile对象的指针以及指向volatile对象的volatile指针.
19. 和const一样，我们只能将一个volatile 对象的地址(或者拷贝一个指向volatile类型的指针)赋给一个指向volatile的指针。同时，只有当某个引用是volatile的时，我们才能使用-一个volatile对象初始化该引用。
20. const和volatile的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋值运算符初始化volatile对象或从volatile对象赋值。合成的成员接受的形参类型是(非volatile)常量引用，显然我们不能把-个非volatile引用绑定到一个volatile对象上。如果一个类希望拷贝、移动或赋值它的volatile 对象，则该类必须自定义拷贝或移动操作。例如，我们可以将形参类型指定为const volatile 引用，这样我们就能利用任意类型的Foo进行拷贝或赋值操作了.
21. C++使用链接指示( linkage directive)指出任意非C++函数所用的语言。
22. 链接指示可以有两种形式:单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。
23. 我们可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个链接。花括号的作用是将适用于该链接指示的多个声明聚合在一起， 否则花括号就会被忽略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的-样。
24. 当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。
25. 编写函数所用的语言是函数类型的一部分。 因此,对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示.
26. 指向C函数的指针与指向C++函数的指针是不一样的类型。
27. 当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效;因为链接指示同时作用于声明语向中的所有函数，所以如果我们希望给C++函数传入一个指向C函数的指针，则必须使用类型别名
28. 通过使用链接指示对函数进行定义，我们可以令-一个C++函数在其他语言编写的程序中可用;值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，我们不太可能把一一个 C++类的对象传给C程序，因为C程序根本无法理解构造函数、析构函数以及其他类特有的操作。
29. 链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为该语言实现链接指示的编译器很可能也支持重载这些C++的函数。C语言不支持函数重载,因此也就不难理解为什么-一个C链接指示只能用于说明- -组.重载函数中的某一个了.
30. ![图片](https://i.328888.xyz/2023/03/09/oCv68.jpeg)
31. 何时共享虚函数地址表
32. 为什么构造函数不应该是虚函数


### CPlusPlusThings
1. [项目链接](https://github.com/Light-City/CPlusPlusThings)
2. const常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符串替换，不能进行安全检查。
3. const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数。
4. const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。
5. 要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。
6. 不能使用void*指针保存const对象的地址，必须使用const void\*类型的指针保存const对象的地址。
7. 对于类中的const成员变量必须通过初始化列表进行初始化 static const可在定义处初始化
8. 在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。
9. 类中的静态变量由对象共享,静态变量不能使用构造函数初始化
10. 就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象;允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。
11. 限定访问范围 static还有限定访问范围的作用（类似于匿名名字空间）
12. 静态函数只是在声明他的文件当中可见，不能被其他文件所用。
13. this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行；个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。编译器自动为我们加上A* const
14. 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
15. 虚继承,继承基类的vptr。
16. 如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。
17. 在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。
18. 构造函数不能是虚函数，而析构函数可以是虚析构函数
19. ![构造函数析构函数](https://i.328888.xyz/2023/03/10/o1QCc.jpeg)
20. 当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。 如果析构函数不是虚拟的，则只能调用基类析构函数。
21. ![虚函数和虚表](https://i.328888.xyz/2023/03/10/oQRRQ.jpeg)
22. 默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型。
23. 静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰
24. 虚函数可以为私有函数吗?
25. inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
26. 被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。
27. 使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化;如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知;volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。
28. 是否了解volatile的应用场景是区分C/C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。
29. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
30. volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
31. 忽略断言，在代码开头加上:`#define NDEBUG`
32. “ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。这种数据结构的一个好处是它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。第二个好处是位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。而这种数据结构的缺点在于，位段实现依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。
33. 赋值时要注意值的大小不能超过位域成员的容量;该位域结构体中间有一个未命名的位域，占据 3 Bits，仅起填充作用，并无实际意义;但 C 语言使用 unsigned int 作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同;一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐;我们也可以使用一个宽度为 0 的未命名位域成员令下一位域成员与下一个整数对齐;
34. 位域的重映射 指针 联合体
35. C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。
36. 而通常为了C代码能够通用，即既能被C调用，又能被C++调用，头文件通常会有如下写法:`extern "C"` 即在C++调用该接口时，会以C接口的方式调用。
37. extern "C"在C中是语法错误，需要放在C++头文件中。
38. 总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。
39. ![struct](https://i.328888.xyz/2023/03/11/sOAC5.jpeg)
40. ![union](https://i.328888.xyz/2023/03/11/sOCVE.jpeg)
41. explicit 修饰构造函数时，可以防止隐式转换和复制初始化;explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外
42. ![friend](https://i.328888.xyz/2023/03/11/sOXlz.jpeg)
43. 类Derived私有继承了Base，对于它来说成员变量n和成员函数size都是私有的，如果使用了using语句，可以改变他们的可访问性，如上述例子中，size可以按public的权限访问，n可以按protected的权限访问;
44. 在派生类中使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。
45. 在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。  条款33
46. 枚举 作用域不受限,会容易引起命名冲突 解决方案 命名空间 结构体
47. 枚举类 不能隐式转换成其他类型 可以指定用特定的类型来存储enum
48. 在类的构造函数的初始化列表中进行const数据成员初始化
49. 类中的枚举常量来实现 建立在整个类中都恒定的常量
50. decltype 与using/typedef合用，用于定义类型;泛型编程中结合auto，用于追踪函数的返回值类型;
51. 对于decltype(e)而言，其判别结果受以下条件的影响：如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&& 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&。 否则，假设e的类型是T，则decltype（e）为T。标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。
52. C++中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，指针与引用底层实现都是一样的，不用担心两者的性能差距。
53. [宏那些事](https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/macro)
54. 

### c++语言程序设计 清华大学 郑莉
1. 表达式的值:赋值运算符左边对象被赋值后的值;表达式的类型:赋值运算符左边对象的类型
2. 常用的 I/O 流类库操纵符
3. 不限定作用域枚举类型; 限定作用域的 enum 类
4. 限定作用域的 enum 类 `int a = Sun;` 到了c++11 `int a = Weekday::Sun;`
5. constexpr 修饰的函数在其所有参数都是 constexpr 时，一定返回 constexpr;函数体中必须有且仅有一条 return 语句
6. initializer_list 比较特殊的一点是，其对象中的元素永远是常量值，我们无法改变 initializer_list 对象中元素的值;含有 initializer_list 形参的函数也可以同时拥有其他形参;
7. 内联函数的定义必须出现在内联函数第一次被调用之前
8. 如果一个函数有原型声明，且原型声明在定义之前，则默认参数值应在函数原型声明 中给出；如果只有函数的定义，或函数定义在前，则默认参数值可以函数定义中给出。
9. 重载函数的形参必须不同:个数不同或类型不同。
10. 构造函数可以是内联函数
11. 下面两个都是默认构造函数，如在类中同时出现，将产生编译错误;
12. 类中基本类型的数据默认初始化的值是不确定的
13. 委托构造函数使用类的其他构造函数执行初始化过程
14. 如果不希望对象被复制构造 1.C++98做法：将复制构造函数声明为private，并且不提供函数的实现 2.C++11做法：用“=delete”指示编译器不生成默认复制构造函数。
15. 按照声明顺序初始化
16. 在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象;当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。
17. 如果一个结构体的全部数据成员都是公共成员，并且没有用户定义的构造函数，没 有基类和虚函数（基类和虚函数将在后面的章节中介绍），这个结构体的变量可以用 下面的语法形式赋初值 大括号初始化
18. 枚举类：强作用域，其作用域限制在枚举类中 转换限制，枚举类对象不可以与整型隐式地互相转换 可以指定底层类型 无法直接比较不同枚举类
19. 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在 内层可见;对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符， 则外层作用域的标识符在内层不可见。
20. 为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。
21. 常数组：数组元素不能被更新;const关键字可以被用于参与对重载函数的区分
22. 文件作用域中定义的变量，默认情况下都是外部变量，但在其它文件中如果需要使 用这一变量，需要用extern关键字加以声明。
23. 在所有类之外声明的函数（也就是非成员函数），都是具有文件作用域的。
24. 这样的函数都可以在不同的编译单元中被调用，只要在调用之前进行引用性声明 （即声明函数原型）即可。也可以在声明函数原型或定义函数时用extern修饰，其 效果与不加修饰的默认状态是一样的。
25. 按标准方式搜索，文件位于C++系统目录的include子目录下;首先在当前目录中搜索，若没有，再按标准方式搜索。
26. 如果只对部分元素初始化，剩下的未显式初始化的元素，将自动被初始化为零；如果不作任何初始化，内部auto型数组中会存在垃圾数据，static数组中的数据默 认初始化为0；
27. 对形参数组的改变会直接影响到实参数组;传送的是数组首地址
28. 不要用一个内部非静态变量去初始化 static 指针。
29. 允许定义或声明指向 void 类型的指针。该指针可以被赋予任何类型对象的地址。
30. 意义是指向下一个或前一个完整数据的起始。
31. 当指针指向连续存储的同类型数据时，指针与整数的加减运和自增自减算才有意义。
32. 实参是数组名时形参可以是指针
33. 函数指针指向的是程序代码存储区。
34. new 结果值：成功：T类型的指针，指向新分配的内存；失败：抛出异常。 数组长度可以是任何表达式，在运行时计算
35. 返回“引用”可以用来操作封装数组对象内部的数组元素。
36. vector数组对象名不表示数组首地址
37. 深层复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针 所指对象进行复制。
38. 默认情况下派生类包含了全部基类中除构造和析构函数之外的所有成员。
39. 如果派生类声明了一个和某基类成员同名的新成员，派生的新成员就隐藏或 覆盖了外层同名成员 所有重载版本 ???
40. protected成员 对建立其所在类对象的模块来说，它与 private 成员的性质相同；对于其派生类来说，它与 public 成员的性质相同。
41. 如果派生类有多个基类，也就是多继承时，可以用不同的方式继承每个基类。
42. 派生类需要定义自己的构造函数。
43. 可用using语句继承基类构造函数;但是只能初始化从基类继承的成员;派生类新增成员可以通过类内初始值进行初始化。
44. 建议：如果派生类有自己新增的成员，且需要通过构造函数初始化，则派生类要自定义构 造函数。
45. 函数重载就体现了静态多态性;
46. 虚函数必须是非静态的成员函数，虚函数经过派生之后，就可以实现运行过程中的 多态。
47. 虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数 的处理是静态的。
48. 虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。
49. 派生类中的虚函数还会隐藏基类中同名函数的所有其它重载形式。 ???
50. 如果返回值为引用。由于引用是对象的别名，通过引用可以改变对象的值，因此是 左值。
51. 如果返回值为引用。由于引用是对象的别名，通过引用可以改变对象的值，因此是 左值。
52. 插入排序 选择排序（选择最大值或最小值） 交换排序（冒泡排序）
53. 使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义 的类型——只要这些类型是所要求概念的模型。
54. 泛型程序设计 和 IO流

### 施磊c++基础

1. 动态库 .dll .so 静态库 .lib .a
2. 任何的编程语言 产生 指令和数据
3. .text .rodata 只能读不能写
4. .data初始化过的(初始化不为0) .bss未初始化或初始化为0  
5. inline在debug时不起作用 inline函数不在生成相应的函数符号
6. 一组函数要称得上重载 一定要在一个作用域中
7. 静态多态：函数重载 模板  动态多态：
8. c语言生成函数符号方式与c++不一样 把c函数的声明扩在 extern “c”里面 表示把该函数符号变成c语言方式
9. __FILE__ __LINE__ 宏
10. 只要是c++编译器 内置了__cplusplus这个宏
11. c中const 常变量 可以不初始化
12. c++中 const 常量 常变量
13. const如果右边没有指针*的话，const是不参与类型的
14. const和二级指针的结合 有点难  
15. 内核空间共享 用户空间私有的
16. 局部非静态变量不产生符号
17. 管道 在内核空间 所以多个进程可以看到
18. 可重定位：
19. #pragma lib 链接库 #pragma link 从什么函数开始执行
20. 动态库不直接参与链接过程
21. 编译阶段 语法分析 代码优化
22. 链接的核心 符号的重定位
23. objdump -t 符号表
24. local符号只在当前文件看得见 global符号别的文件也能看见
25. 函数里面定义的非静态变量不产生符号 对应在.text段的指令 运行时开辟一块内存存储数据
26. readelf -h link.o 看文件头
27. .o文件是一段一段组成的 符号表在编译过程中不分配虚拟地址 链接才分配
28. objdump -S *.o 反汇编
29. 合并段 其中有符号表的合并 符号解析（找到该符号定义的地方） 符号的重定位 （为所有符号分配虚拟地址）
30. int a = 10 int * p1 = &a const int ** p2 = &p1 这样不对 因为*p2可以改变a 但是**p2不能改变a 这是矛盾的
31. 每一个对象都有自己的成员变量 但是它们共享一套成员方法
32. 指向类成员的指针 静态不需要对象
33. compare是一个函数模版 compare<int>才是一个函数名 模板函数 模版的实例化
34. 模版的特化 
35. 告诉编译器 进行指定类型的模版实例化
36. 模版正确使用方法 include进来
37. 模板的非类型参数 必须是整数类型
38. 类中可以访问其他对象的私有成员 因为是在类中
39. 类模板的选择性实例化 类模板的默认类型参数
40. 空间配置器 可以把 开辟内存 构造对象 析构对象 释放内存 这些步骤分开 就不会大量的构造析构 提升效率
41. 说详细一点 回答问题 有逻辑 挖深一点
42. 如果用临时对象拷贝构造新对象，那么临时对象就不产生了，直接构造新对象就行了
43. 引用临时变量是可以的
44. 常量数字 临时量都是右值
45. forward完美转发