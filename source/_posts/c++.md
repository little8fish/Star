---
title: c++
abbrlink: 21be6370
date: 2023-03-02 10:27:03
tags: [essential c++]
categories: 阅读记录
cover: https://images.unsplash.com/photo-1677613935629-5de03180c113?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=735&q=80
---
{% note info simple %}
1. 局部对象以传值方式返回，便不会产生任何问题，因为返回的是对象的副本；局部对象以pointer或reference返回，都不正确。
2. 对象如果在函数以外声明，具有所谓的file scope；file scope内的对象具备所谓的static extent，即该对象的内存在main()开始执行之前便已经分配好了，可以一直存在至程序结束。
3. 内置类型的对象，如果定义在file scope之内，必定被初始化为0；但如果他们被定义于local scope之内，那么要手动初始化。
4. 不论是local scope或file scope，对我们而言，都是由系统自动管理；第三种存储期形式称为dynamic extent（动态范围）；其内存系程序的空闲空间分配而来，有时也称为heap memory（堆内存）。
5. 函数参数默认值只能够指定一次，可以在函数声明处，也可以在函数定义处，但不能够在两个地方都指定；为了更高的可见性，我们决定将默认值放在函数声明处。
6. 局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在；局部静态对象与全局变量共享全局数据区，但局部静态对象只在定义它的函数中可见
7. 将函数声明为inline，只是对编译器提出的一种要求；编译器是否执行这项请求，需视编译器而定
8. 编译器无法根据函数返回类型来区分两个具有相同名称的函数
9. function template同时也可以是重载函数
10. 函数指针调用方式：函数指针名（参数）；还有函数指针数组`int (*fun_ptr[])(void)`
11. 函数的定义只能有一份，不过可以有许多份声明；我们不把函数的定义放入头文件，因为同一个程序的多个代码文件可能都会包含这个头文件
12. “只定义一份”有个例外，inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中
13. 如果文件被认定为标准的或项目专属的头文件，便以尖括号将文件名括住；编译器搜索此文件时，会现在某些默认的磁盘目录中寻找。若果文件名由成对的双引号括住，比文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件所在的磁盘目录中开始找起
14. const object的定义只要一出文件之外便不可见
{% endnote %}

### effective c++

1. 语言联邦
2. 替换掉#define

### modern c++

1. auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。
2. 现代 C++ 还为自身的标准库增加了非常多的工具和方法，诸如在语言自身标准的层面上制定了 std::thread，从而支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex 提供了完整的正则表达式支持等等。
3. 本书将使用 clang++ 作为唯一使用的编译器，同时总是在代码中使用 -std=c++2a 编译标志
4. 弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。
5. ![弃用特性](https://i.328888.xyz/2023/03/06/deBrz.jpeg)
6. 在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern "C" 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法
7. Makefile 中的缩进是制表符而不是空格符，如果你直接复制这段代码到你的编辑器中，制表符可能会被自动替换掉，请自行确保在 Makefile 中的缩进是由制表符完成的。
8.  C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较.
9.  C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。
10. C++ 标准中数组的长度必须是一个常量表达式;
11. 现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。
12. C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 len_foo 在编译期就应该是一个常量表达式。
13. C++17 消除了这一限制，使得我们可以在 if（或 switch）中声明一个临时的变量
14. C++11 首先把初始化列表的概念绑定到类型上，称其为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁。这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。
15. 初始化列表除了用在对象构造上，还能将其作为普通函数的形参.
16. 提供一种简单的方法直接从元组中拿到并定义元组中的元素 结构化绑定 `auto [x, y, z] = f();`
17. decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。`decltype(x+y) z;`z的类型为`decltype(x+y)`
18. 从 C++ 20 起，auto 甚至能用于函数传参;auto 还不能用于推导数组类型
19. typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义
20. C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置
21. 令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导
22. decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。
23. C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件;if constexpr 让代码在编译时就完成分支判断
24. 区间for迭代
25. 模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。
26. C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化
27. 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。
28. C++11 使用 using 引入了为模板定义一个新的名称，并且同时支持对传统 typedef 相同的功效
29. 而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。```template<typename Require, typename... Args> class Magic;```
30. 传统 C 中的 printf 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。
31. 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 printf 的函数能自然地处理非自带类别的对象。
32.  除了在模板参数中能使用 ... 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段
33.  我们可以使用 sizeof... 来计算参数的个数
34. 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法: 递归模板函数 变参模板展开
35. 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。
36. 初始化列表展开  通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。 为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void。
37. C++ 17 中将变长参数这种特性进一步带给了表达式 ```auto sum(T ... t) {
    return (t + ...);
}```
38. 还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数
39. 既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 auto 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导
40. C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的
41. 在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念
42. 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译
43. final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。
44. 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。 当程序员有需要时，可以重载这部分函数。
45. 编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬
46. 允许显式的声明采用或拒绝编译器自带的函数。
47. 在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果
48. C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明  这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较
49. 在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。
50. 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 << 这个算符来进行输出，可以收藏下面这个代码段： 这段代码不懂
51. 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。
52. 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝
53. 与引用传参类似，引用捕获保存的是引用，值会发生变化
54. 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用引用捕获或者值捕获.
55. C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的
56. 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型
57. Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递
58. 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。
59. C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。
60.  std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用
61.  注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 auto 的使用来规避这一问题的出现。
62.  左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。
63.  左值能取地址 右值不能取地址
64.  需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。
65.  const char*&& pr  = "01234";  // 正确，"01234" 被隐式转换为 const char*，该转换的结果是纯右值
66.  将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。
67.  此处的左值 temp 会被进行此隐式右值转换， 等价于 static_cast<std::vector<int> &&>(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。 
68.  要拿到一个将亡值，就需要用到右值引用：T &&，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。
69.  C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象
70.  rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。
71.  对右值引用后 有了名字 这个名字就成了左值
72.  左值引用只能绑定左值 右值引用只能绑定右值
73.  常量左值引用可以绑定非常量左值、常量左值、右值 而且绑定右值的时候 常量左值引用还可以像右值引用一样将右值的生命期延长
74.  右值引用将右值的生命期延长
75.  这里介绍了左值 右值 移动语义 完美转发 https://www.bilibili.com/video/BV1D84y1z7kT/?p=3&spm_id_from=pageDriver&vd_source=8f841660eaffa503121a503667bfc063
76.      // 将使用 push_back(const T&&), 不会出现拷贝行为
    // 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销
    // 这步操作后, str 中的值会变为空 为什么会变空 移动吗
    v.push_back(std::move(str));
77.  一个声明的右值引用其实是一个左值
78.  无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发， 所以 std::move 总会接受到一个左值，从而转发调用了reference(int&&) 输出右值引用。
79.  std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看， std::forward<T>(v) 和 static_cast<T&&>(v) 是完全一样的。
80.  当 std::forward 接受左值时，_Tp 被推导为左值，所以返回值为左值；而当其接受右值时， _Tp 被推导为 右值引用，则基于坍缩规则，返回值便成为了 && + && 的右值。 可见 std::forward 的原理在于巧妙的利用了模板类型推导中产生的差异。  这一句不懂
81.  为什么在使用循环语句的过程中，auto&& 是最安全的方式？ 因为当 auto 被推导为不同的左右引用时，与 && 的坍缩组合是完美转发。
82.  
83.  引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。

