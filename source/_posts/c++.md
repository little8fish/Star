---
title: c++
abbrlink: 21be6370
date: 2023-03-02 10:27:03
tags: [essential c++]
categories: 阅读记录
cover: https://images.unsplash.com/photo-1677613935629-5de03180c113?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=735&q=80
---
{% note info simple %}
1. 局部对象以传值方式返回，便不会产生任何问题，因为返回的是对象的副本；局部对象以pointer或reference返回，都不正确。
2. 对象如果在函数以外声明，具有所谓的file scope；file scope内的对象具备所谓的static extent，即该对象的内存在main()开始执行之前便已经分配好了，可以一直存在至程序结束。
3. 内置类型的对象，如果定义在file scope之内，必定被初始化为0；但如果他们被定义于local scope之内，那么要手动初始化。
4. 不论是local scope或file scope，对我们而言，都是由系统自动管理；第三种存储期形式称为dynamic extent（动态范围）；其内存系程序的空闲空间分配而来，有时也称为heap memory（堆内存）。
5. 函数参数默认值只能够指定一次，可以在函数声明处，也可以在函数定义处，但不能够在两个地方都指定；为了更高的可见性，我们决定将默认值放在函数声明处。
6. 局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在；局部静态对象与全局变量共享全局数据区，但局部静态对象只在定义它的函数中可见
7. 将函数声明为inline，只是对编译器提出的一种要求；编译器是否执行这项请求，需视编译器而定
8. 编译器无法根据函数返回类型来区分两个具有相同名称的函数
9. function template同时也可以是重载函数
10. 函数指针调用方式：函数指针名（参数）；还有函数指针数组`int (*fun_ptr[])(void)`
11. 函数的定义只能有一份，不过可以有许多份声明；我们不把函数的定义放入头文件，因为同一个程序的多个代码文件可能都会包含这个头文件
12. “只定义一份”有个例外，inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中
13. 如果文件被认定为标准的或项目专属的头文件，便以尖括号将文件名括住；编译器搜索此文件时，会现在某些默认的磁盘目录中寻找。若果文件名由成对的双引号括住，比文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件所在的磁盘目录中开始找起
14. const object的定义只要一出文件之外便不可见
{% endnote %}

### effective c++

1. 语言联邦
2. 替换掉#define

### modern c++
1. auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。
2. 被弃用的特性 字符串 auto_ptr c语言风格类型转换 等等
3. extern "C" 将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法
4. makefile中的缩进是制表符
5. C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。
6. 现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。
7. constexpr 不理解
8. if/switch 变量声明强化
9. C++11 首先把初始化列表的概念绑定到类型上，称其为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁
10. 提供一种简单的方法直接从元组中拿到并定义元组中的元素
11. decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。
12. C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置
13. decltype(auto) 未看
14. if constexpr 让代码在编译时就完成分支判断
15. 区间for迭代
16. 模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。
17. C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化
18. 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。
19. C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效
20. 而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。
21. 传统 C 中的 printf 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。
22. 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 printf 的函数能自然地处理非自带类别的对象。
23. 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法
24. 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。
25. 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译
26. final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。
27. 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。 当程序员有需要时，可以重载这部分函数。
28. 编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。
29. 在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果
30. 在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。
31. 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 << 这个算符来进行输出，可以收藏下面这个代码段： 这段代码不懂
32. 值捕获那里不懂
33. 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型
34. 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。
35. C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。
36.  std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用
37.  注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 auto 的使用来规避这一问题的出现。
38.  需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。
39.  左值能取地址 右值不能取地址
40.  对右值引用后 有了名字 这个名字就成了左值
41.  左值引用只能绑定左值 右值引用只能绑定右值
42.  常量左值引用可以绑定非常量左值、常量左值、右值 而且绑定右值的时候 常量左值引用还可以像右值引用一样将右值的生命期延长
43.  右值引用将右值的生命期延长
44.  这里介绍了左值 右值 移动语义 完美转发 https://www.bilibili.com/video/BV1D84y1z7kT/?p=3&spm_id_from=pageDriver&vd_source=8f841660eaffa503121a503667bfc063
45.  std::move后 原值会变空
46.  为什么在使用循环语句的过程中，auto&& 是最安全的方式？ 因为当 auto 被推导为不同的左右引用时，与 && 的坍缩组合是完美转发。
47.  