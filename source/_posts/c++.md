---
title: c++
abbrlink: 21be6370
date: 2023-03-02 10:27:03
top: 1
tags: [essential c++]
categories: 阅读记录
cover: https://images.unsplash.com/photo-1677613935629-5de03180c113?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=735&q=80
---
{% note info simple %}
1. 局部对象以传值方式返回，便不会产生任何问题，因为返回的是对象的副本；局部对象以pointer或reference返回，都不正确。
2. 对象如果在函数以外声明，具有所谓的file scope；file scope内的对象具备所谓的static extent，即该对象的内存在main()开始执行之前便已经分配好了，可以一直存在至程序结束。
3. 内置类型的对象，如果定义在file scope之内，必定被初始化为0；但如果他们被定义于local scope之内，那么要手动初始化。
4. 不论是local scope或file scope，对我们而言，都是由系统自动管理；第三种存储期形式称为dynamic extent（动态范围）；其内存系程序的空闲空间分配而来，有时也称为heap memory（堆内存）。
5. 函数参数默认值只能够指定一次，可以在函数声明处，也可以在函数定义处，但不能够在两个地方都指定；为了更高的可见性，我们决定将默认值放在函数声明处。
6. 局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在；局部静态对象与全局变量共享全局数据区，但局部静态对象只在定义它的函数中可见
7. 将函数声明为inline，只是对编译器提出的一种要求；编译器是否执行这项请求，需视编译器而定
8. 编译器无法根据函数返回类型来区分两个具有相同名称的函数
9. function template同时也可以是重载函数
10. 函数指针调用方式：函数指针名（参数）；还有函数指针数组`int (*fun_ptr[])(void)`
11. 函数的定义只能有一份，不过可以有许多份声明；我们不把函数的定义放入头文件，因为同一个程序的多个代码文件可能都会包含这个头文件
12. “只定义一份”有个例外，inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中
13. 如果文件被认定为标准的或项目专属的头文件，便以尖括号将文件名括住；编译器搜索此文件时，会现在某些默认的磁盘目录中寻找。若果文件名由成对的双引号括住，比文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件所在的磁盘目录中开始找起
14. const object的定义只要一出文件之外便不可见
{% endnote %}

### effective c++
1. 四个语言层次
2. const替换#define 常量声明式 
3. 

### modern c++

1. auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。
2. 现代 C++ 还为自身的标准库增加了非常多的工具和方法，诸如在语言自身标准的层面上制定了 std::thread，从而支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex 提供了完整的正则表达式支持等等。
3. 本书将使用 clang++ 作为唯一使用的编译器，同时总是在代码中使用 -std=c++2a 编译标志
4. 弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。
5. ![弃用特性](https://i.328888.xyz/2023/03/06/deBrz.jpeg)
6. 在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern "C" 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法
7. Makefile 中的缩进是制表符而不是空格符，如果你直接复制这段代码到你的编辑器中，制表符可能会被自动替换掉，请自行确保在 Makefile 中的缩进是由制表符完成的。
8.  C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较.
9.  C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。
10. C++ 标准中数组的长度必须是一个常量表达式;
11. 现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。
12. C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 len_foo 在编译期就应该是一个常量表达式。
13. C++17 消除了这一限制，使得我们可以在 if（或 switch）中声明一个临时的变量
14. C++11 首先把初始化列表的概念绑定到类型上，称其为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁。这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。
15. 初始化列表除了用在对象构造上，还能将其作为普通函数的形参.
16. 提供一种简单的方法直接从元组中拿到并定义元组中的元素 结构化绑定 `auto [x, y, z] = f();`
17. decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。`decltype(x+y) z;`z的类型为`decltype(x+y)`
18. 从 C++ 20 起，auto 甚至能用于函数传参;auto 还不能用于推导数组类型
19. typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义
20. C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置
21. 令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导
22. decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。
23. C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件;if constexpr 让代码在编译时就完成分支判断
24. 区间for迭代
25. 模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。
26. C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化
27. 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。
28. C++11 使用 using 引入了为模板定义一个新的名称，并且同时支持对传统 typedef 相同的功效
29. 而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。```template<typename Require, typename... Args> class Magic;```
30. 传统 C 中的 printf 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。
31. 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 printf 的函数能自然地处理非自带类别的对象。
32.  除了在模板参数中能使用 ... 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段
33.  我们可以使用 sizeof... 来计算参数的个数
34. 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法: 递归模板函数 变参模板展开
35. 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。
36. 初始化列表展开  通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。 为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void。
37. C++ 17 中将变长参数这种特性进一步带给了表达式 ```auto sum(T ... t) {
    return (t + ...);
}```
38. 还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数
39. 既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 auto 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导
40. C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的
41. 在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念
42. 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译
43. final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。
44. 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。 当程序员有需要时，可以重载这部分函数。
45. 编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬
46. 允许显式的声明采用或拒绝编译器自带的函数。
47. 在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果
48. C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明  这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较
49. 在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。
50. 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 << 这个算符来进行输出，可以收藏下面这个代码段： 这段代码不懂
51. 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。
52. 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝
53. 与引用传参类似，引用捕获保存的是引用，值会发生变化
54. 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用引用捕获或者值捕获.
55. C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的
56. 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型
57. Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递
58. 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。
59. C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。
60.  std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用
61.  注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 auto 的使用来规避这一问题的出现。
62.  左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。
63.  左值能取地址 右值不能取地址
64.  需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。
65.  const char*&& pr  = "01234";  // 正确，"01234" 被隐式转换为 const char*，该转换的结果是纯右值
66.  将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。
67.  此处的左值 temp 会被进行此隐式右值转换， 等价于 static_cast<std::vector<int> &&>(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。 
68.  要拿到一个将亡值，就需要用到右值引用：T &&，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。
69.  C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象
70.  rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。
71.  对右值引用后 有了名字 这个名字就成了左值
72.  左值引用只能绑定左值 右值引用只能绑定右值
73.  常量左值引用可以绑定非常量左值、常量左值、右值 而且绑定右值的时候 常量左值引用还可以像右值引用一样将右值的生命期延长
74.  右值引用将右值的生命期延长
75.  这里介绍了左值 右值 移动语义 完美转发 https://www.bilibili.com/video/BV1D84y1z7kT/?p=3&spm_id_from=pageDriver&vd_source=8f841660eaffa503121a503667bfc063
76.      // 将使用 push_back(const T&&), 不会出现拷贝行为
    // 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销
    // 这步操作后, str 中的值会变为空 为什么会变空 移动吗
    v.push_back(std::move(str));
77.  一个声明的右值引用其实是一个左值
78.  无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发， 所以 std::move 总会接受到一个左值，从而转发调用了reference(int&&) 输出右值引用。
79.  std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看， std::forward<T>(v) 和 static_cast<T&&>(v) 是完全一样的。
80.  当 std::forward 接受左值时，_Tp 被推导为左值，所以返回值为左值；而当其接受右值时， _Tp 被推导为 右值引用，则基于坍缩规则，返回值便成为了 && + && 的右值。 可见 std::forward 的原理在于巧妙的利用了模板类型推导中产生的差异。  这一句不懂
81.  为什么在使用循环语句的过程中，auto&& 是最安全的方式？ 因为当 auto 被推导为不同的左右引用时，与 && 的坍缩组合是完美转发。
82.  先回答第一个问题，与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 std::array 容器。 另外由于 std::vector 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 shrink_to_fit() 释放这部分内存。
83.  当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法
84.  需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。
85.  我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 < 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 < 操作符的顺序来逐个遍历。
86.  而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)， 在不关心容器内部元素顺序时，能够获得显著的性能提升。
87.  关于元组的使用有三个核心的函数：
    std::make_tuple: 构造元组
    std::get: 获得元组某个位置的值
    std::tie: 元组拆包
88.  std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象
89.  std::get<> 依赖一个编译期的常量，所以下面的方式是不合法的
90.  还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现
91.  std::tuple 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他的方法可以自行实现。
92.  引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。
93.  所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。
94.  而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 <memory>。
95.  引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。
96.  std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。std::make_shared 就能够用来消除显式的使用 new，所以std::make_shared 会分配创建传入参数中的对象， 并返回这个对象类型的std::shared_ptr指针。
97.  std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。
98.  所有的共享指针被摧毁 而裸指针依然存在时 内存依旧会被释放 而此时访问裸指针就变成了未被定义的行为 记住 智能指针和裸指针不要混用
99.  std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全
100. reset可以指向一个新的内存 sp.reset(new Ball)
101. 可以自定义一个删除函数 告诉share_ptr如何释放资源
102. shared_ptr别名 `shared_ptr<Bar> b(f, &(f->bar))` b拥有对f指向物体的管理权 f引用计数增加1 b的数据指针指向的是bar 通常这个技巧用于访问类的成员变量 我们访问的是某个实例的成员 但是我们不希望在用这个成员的时候 实例本身被删除 所以我们增加了对这个实例的控制权 额外性能开销
103. 在使用智能指针的时候 尽量避免使用手动的delete
104. 但是，我们可以利用 std::move 将其转移给其他的 unique_ptr 0开销
105. unique_ptr可以用release返回裸指针 并把unique_ptr设置为nullptr 把unique_ptr赋值为nullptr也会释放资源  return返回 自动帮我们使用移动构造 传递时设置u_p的引用 
106. 默认情况下 u_p使用new delete获取释放资源 也可以自定义 u_p绑定释放函数是在编译器  s_p是在运行期
107. std::shared_ptr 就会发现依然存在着资源无法释放的问题。
108. 弱引用不会引起引用计数增加
109. std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true；除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回nullptr。
110. 智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在一定程度上消除了 new/delete 的滥用，是一种更加成熟的编程范式。
111. 智能指针快速讲解视频 ——> [hexup的视频](https://www.bilibili.com/video/BV1Ye4y127rZ/?spm_id_from=333.999.0.0&vd_source=8f841660eaffa503121a503667bfc063)
112. 正则表达式
113. 并行与并发
114. 文件系统
115. 其它
116. 展望
117. 

